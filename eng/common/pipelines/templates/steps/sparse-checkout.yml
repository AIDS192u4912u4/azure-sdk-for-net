parameters:
  - name: Paths
    type: object
    default: []
  - name: Repositories
    type: object
    default:
      - Name: $(Build.Repository.Name)
        Commitish: $(Build.SourceVersion)
        WorkingDirectory: $(System.DefaultWorkingDirectory)
  - name: SkipCheckoutNone
    type: boolean
    default: false

steps:
  - ${{ if not(parameters.SkipCheckoutNone) }}:
      - checkout: none

  - task: PowerShell@2
    ${{ if eq(length(parameters.Repositories), 1) }}:
      displayName: 'Sparse checkout ${{ parameters.Repositories[0].Name }}'
    ${{ else }}:
      displayName: 'Sparse checkout repositories'
    inputs:
      targetType: inline
      script: |
        $PSNativeCommandArgumentPassing = 'Legacy'
        function SparseCheckout([Array]$paths, [Hashtable]$repository)
        {
            $dir = $repository.WorkingDirectory
            if (!$dir) {
              $dir = "./$($repository.Name)"
            }
            New-Item $dir -ItemType Directory -Force | Out-Null
            Push-Location $dir
            if (Test-Path .git/info/sparse-checkout) {
              $hasInitialized = $true
            } else {
              if ($repository.Commitish -match '^refs/pull/\d+/merge$') {
                git clone --no-checkout --filter=tree:0 -c remote.origin.fetch=''+$($repository.Commitish):refs/remotes/origin/$($repository.Commitish)'' https://github.com/$($repository.Name) .
              } else {
        }
        $paths = '${{ convertToJson(parameters.Paths) }}'.Trim('"') | ConvertFrom-Json
        $repositories = '${{ convertToJson(parameters.Repositories) }}' -replace '\\', '/' | ConvertFrom-Json -AsHashtable
        foreach ($repo in $Repositories) {
          SparseCheckout $paths $repo
        }
      pwsh: true
      workingDirectory: $(System.DefaultWorkingDirectory)
